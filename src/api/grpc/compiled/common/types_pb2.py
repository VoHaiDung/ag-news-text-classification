"""
Generated Protocol Buffer code for Common Types
================================================================================
This file is automatically generated by the Protocol Buffer compiler.
DO NOT EDIT MANUALLY - changes will be overwritten.

Generated from: src/api/grpc/protos/common/types.proto

These types provide reusable message definitions for common data structures
used across multiple services.
"""

import sys
from typing import Optional, Dict, Any, List

_b = sys.version_info[0] < 3 and (lambda x: x) or (lambda x: x.encode('latin1'))

from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import timestamp_pb2
from google.protobuf import duration_pb2
from google.protobuf import struct_pb2

# Symbol database
_sym_db = _symbol_database.Default()


class Timestamp(_message.Message):
    """
    Timestamp message for representing time points
    
    Attributes:
        seconds: Seconds since Unix epoch
        nanos: Nanoseconds within the second
    """
    __slots__ = ['seconds', 'nanos']
    
    def __init__(self, seconds: int = 0, nanos: int = 0):
        super(Timestamp, self).__init__()
        self.seconds = seconds
        self.nanos = nanos


class Metadata(_message.Message):
    """
    Generic metadata container for key-value pairs
    
    Attributes:
        entries: Dictionary of metadata key-value pairs
    """
    __slots__ = ['entries']
    
    def __init__(self, entries: Optional[Dict[str, str]] = None):
        super(Metadata, self).__init__()
        if entries:
            self.entries.update(entries)


class Pagination(_message.Message):
    """
    Pagination parameters for list operations
    
    Attributes:
        page_size: Number of items per page
        page_token: Token for retrieving specific page
        total_items: Total number of items available
        next_page_token: Token for next page
        prev_page_token: Token for previous page
    """
    __slots__ = ['page_size', 'page_token', 'total_items', 'next_page_token', 'prev_page_token']
    
    def __init__(self, 
                 page_size: int = 10,
                 page_token: str = "",
                 total_items: int = 0,
                 next_page_token: str = "",
                 prev_page_token: str = ""):
        super(Pagination, self).__init__()
        self.page_size = page_size
        self.page_token = page_token
        self.total_items = total_items
        self.next_page_token = next_page_token
        self.prev_page_token = prev_page_token


class SortOrder(_message.Message):
    """
    Sort order specification for list operations
    
    Attributes:
        field: Field name to sort by
        direction: Sort direction (ASC or DESC)
    """
    
    class Direction:
        """Sort direction enumeration"""
        UNSPECIFIED = 0
        ASC = 1
        DESC = 2
    
    __slots__ = ['field', 'direction']
    
    def __init__(self, field: str = "", direction: int = 0):
        super(SortOrder, self).__init__()
        self.field = field
        self.direction = direction


class FieldMask(_message.Message):
    """
    Field mask for partial resource updates
    
    Attributes:
        paths: List of field paths to include/update
    """
    __slots__ = ['paths']
    
    def __init__(self, paths: Optional[List[str]] = None):
        super(FieldMask, self).__init__()
        if paths:
            self.paths.extend(paths)


class ErrorDetail(_message.Message):
    """
    Detailed error information
    
    Attributes:
        code: Error code
        message: Error message
        field: Field that caused the error
        metadata: Additional error metadata
    """
    __slots__ = ['code', 'message', 'field', 'metadata']
    
    def __init__(self,
                 code: str = "",
                 message: str = "",
                 field: str = "",
                 metadata: Optional[Dict[str, str]] = None):
        super(ErrorDetail, self).__init__()
        self.code = code
        self.message = message
        self.field = field
        if metadata:
            self.metadata.update(metadata)


class RequestOptions(_message.Message):
    """
    Common request options
    
    Attributes:
        timeout: Request timeout in seconds
        retry_count: Number of retries
        trace_id: Request trace identifier
        priority: Request priority level
        cache_control: Cache control directives
    """
    
    class Priority:
        """Request priority levels"""
        LOW = 0
        NORMAL = 1
        HIGH = 2
        CRITICAL = 3
    
    __slots__ = ['timeout', 'retry_count', 'trace_id', 'priority', 'cache_control']
    
    def __init__(self,
                 timeout: int = 30,
                 retry_count: int = 3,
                 trace_id: str = "",
                 priority: int = 1,
                 cache_control: str = ""):
        super(RequestOptions, self).__init__()
        self.timeout = timeout
        self.retry_count = retry_count
        self.trace_id = trace_id
        self.priority = priority
        self.cache_control = cache_control


class ResponseMetadata(_message.Message):
    """
    Common response metadata
    
    Attributes:
        request_id: Unique request identifier
        processing_time_ms: Processing time in milliseconds
        server_info: Server information
        cache_hit: Whether response was served from cache
        rate_limit_info: Rate limiting information
    """
    __slots__ = ['request_id', 'processing_time_ms', 'server_info', 'cache_hit', 'rate_limit_info']
    
    class RateLimitInfo(_message.Message):
        """Rate limiting information"""
        __slots__ = ['limit', 'remaining', 'reset_time']
        
        def __init__(self, limit: int = 0, remaining: int = 0, reset_time: int = 0):
            super(ResponseMetadata.RateLimitInfo, self).__init__()
            self.limit = limit
            self.remaining = remaining
            self.reset_time = reset_time
    
    def __init__(self,
                 request_id: str = "",
                 processing_time_ms: int = 0,
                 server_info: str = "",
                 cache_hit: bool = False,
                 rate_limit_info: Optional[RateLimitInfo] = None):
        super(ResponseMetadata, self).__init__()
        self.request_id = request_id
        self.processing_time_ms = processing_time_ms
        self.server_info = server_info
        self.cache_hit = cache_hit
        if rate_limit_info:
            self.rate_limit_info.CopyFrom(rate_limit_info)


# Register message types
_sym_db.RegisterMessage(Timestamp)
_sym_db.RegisterMessage(Metadata)
_sym_db.RegisterMessage(Pagination)
_sym_db.RegisterMessage(SortOrder)
_sym_db.RegisterMessage(FieldMask)
_sym_db.RegisterMessage(ErrorDetail)
_sym_db.RegisterMessage(RequestOptions)
_sym_db.RegisterMessage(ResponseMetadata)
