"""
Generated Protocol Buffer code for Monitoring Service
================================================================================
This file is automatically generated by the Protocol Buffer compiler.
DO NOT EDIT MANUALLY - changes will be overwritten.

Generated from: src/api/grpc/protos/monitoring.proto

Defines messages for system monitoring, metrics collection, and alerting.
"""

import sys
from typing import Optional, List, Dict, Any
from datetime import datetime

_b = sys.version_info[0] < 3 and (lambda x: x) or (lambda x: x.encode('latin1'))

from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import timestamp_pb2
from google.protobuf import duration_pb2

# Symbol database
_sym_db = _symbol_database.Default()

# Import common types
from .common import types_pb2, status_pb2


class Metric(_message.Message):
    """
    Metric data point
    
    Attributes:
        name: Metric name
        value: Metric value
        type: Metric type
        labels: Metric labels
        timestamp: Metric timestamp
        unit: Measurement unit
    """
    
    class MetricType:
        """Metric type enumeration"""
        UNSPECIFIED = 0
        COUNTER = 1
        GAUGE = 2
        HISTOGRAM = 3
        SUMMARY = 4
    
    __slots__ = ['name', 'value', 'type', 'labels', 'timestamp', 'unit']
    
    def __init__(self,
                 name: str = "",
                 value: float = 0.0,
                 type: int = 0,
                 labels: Optional[Dict[str, str]] = None,
                 timestamp: Optional[timestamp_pb2.Timestamp] = None,
                 unit: str = ""):
        super(Metric, self).__init__()
        self.name = name
        self.value = value
        self.type = type
        if labels:
            self.labels.update(labels)
        if timestamp:
            self.timestamp.CopyFrom(timestamp)
        self.unit = unit


class MetricBatch(_message.Message):
    """
    Batch of metrics
    
    Attributes:
        metrics: List of metrics
        source: Metrics source
        batch_id: Batch identifier
    """
    __slots__ = ['metrics', 'source', 'batch_id']
    
    def __init__(self,
                 metrics: Optional[List[Metric]] = None,
                 source: str = "",
                 batch_id: str = ""):
        super(MetricBatch, self).__init__()
        if metrics:
            self.metrics.extend(metrics)
        self.source = source
        self.batch_id = batch_id


class Alert(_message.Message):
    """
    Alert message
    
    Attributes:
        alert_id: Alert identifier
        name: Alert name
        severity: Alert severity
        message: Alert message
        source: Alert source
        labels: Alert labels
        triggered_at: Trigger timestamp
        resolved_at: Resolution timestamp
    """
    
    class Severity:
        """Alert severity levels"""
        INFO = 0
        WARNING = 1
        ERROR = 2
        CRITICAL = 3
    
    __slots__ = ['alert_id', 'name', 'severity', 'message', 'source',
                 'labels', 'triggered_at', 'resolved_at']
    
    def __init__(self,
                 alert_id: str = "",
                 name: str = "",
                 severity: int = 0,
                 message: str = "",
                 source: str = "",
                 labels: Optional[Dict[str, str]] = None,
                 triggered_at: Optional[timestamp_pb2.Timestamp] = None,
                 resolved_at: Optional[timestamp_pb2.Timestamp] = None):
        super(Alert, self).__init__()
        self.alert_id = alert_id
        self.name = name
        self.severity = severity
        self.message = message
        self.source = source
        if labels:
            self.labels.update(labels)
        if triggered_at:
            self.triggered_at.CopyFrom(triggered_at)
        if resolved_at:
            self.resolved_at.CopyFrom(resolved_at)


class RecordMetricsRequest(_message.Message):
    """
    Request to record metrics
    
    Attributes:
        metrics: Metrics to record
        batch_mode: Use batch processing
        async_mode: Process asynchronously
    """
    __slots__ = ['metrics', 'batch_mode', 'async_mode']
    
    def __init__(self,
                 metrics: Optional[List[Metric]] = None,
                 batch_mode: bool = False,
                 async_mode: bool = False):
        super(RecordMetricsRequest, self).__init__()
        if metrics:
            self.metrics.extend(metrics)
        self.batch_mode = batch_mode
        self.async_mode = async_mode


class RecordMetricsResponse(_message.Message):
    """
    Response for metrics recording
    
    Attributes:
        success: Recording success status
        recorded_count: Number of metrics recorded
        failed_count: Number of failed recordings
        metadata: Response metadata
    """
    __slots__ = ['success', 'recorded_count', 'failed_count', 'metadata']
    
    def __init__(self,
                 success: bool = False,
                 recorded_count: int = 0,
                 failed_count: int = 0,
                 metadata: Optional[types_pb2.ResponseMetadata] = None):
        super(RecordMetricsResponse, self).__init__()
        self.success = success
        self.recorded_count = recorded_count
        self.failed_count = failed_count
        if metadata:
            self.metadata.CopyFrom(metadata)


class QueryMetricsRequest(_message.Message):
    """
    Request to query metrics
    
    Attributes:
        query: Metrics query expression
        start_time: Query start time
        end_time: Query end time
        aggregation: Aggregation method
        group_by: Grouping labels
        limit: Result limit
    """
    
    class Aggregation:
        """Aggregation methods"""
        NONE = 0
        AVG = 1
        SUM = 2
        MIN = 3
        MAX = 4
        COUNT = 5
        RATE = 6
    
    __slots__ = ['query', 'start_time', 'end_time', 'aggregation', 
                 'group_by', 'limit']
    
    def __init__(self,
                 query: str = "",
                 start_time: Optional[timestamp_pb2.Timestamp] = None,
                 end_time: Optional[timestamp_pb2.Timestamp] = None,
                 aggregation: int = 0,
                 group_by: Optional[List[str]] = None,
                 limit: int = 100):
        super(QueryMetricsRequest, self).__init__()
        self.query = query
        if start_time:
            self.start_time.CopyFrom(start_time)
        if end_time:
            self.end_time.CopyFrom(end_time)
        self.aggregation = aggregation
        if group_by:
            self.group_by.extend(group_by)
        self.limit = limit


class QueryMetricsResponse(_message.Message):
    """
    Response with queried metrics
    
    Attributes:
        metrics: Query results
        total_count: Total number of results
        metadata: Response metadata
    """
    __slots__ = ['metrics', 'total_count', 'metadata']
    
    def __init__(self,
                 metrics: Optional[List[Metric]] = None,
                 total_count: int = 0,
                 metadata: Optional[types_pb2.ResponseMetadata] = None):
        super(QueryMetricsResponse, self).__init__()
        if metrics:
            self.metrics.extend(metrics)
        self.total_count = total_count
        if metadata:
            self.metadata.CopyFrom(metadata)


class GetSystemStatusRequest(_message.Message):
    """
    Request for system status
    
    Attributes:
        include_metrics: Include system metrics
        include_services: Include service status
        include_resources: Include resource usage
    """
    __slots__ = ['include_metrics', 'include_services', 'include_resources']
    
    def __init__(self,
                 include_metrics: bool = True,
                 include_services: bool = True,
                 include_resources: bool = True):
        super(GetSystemStatusRequest, self).__init__()
        self.include_metrics = include_metrics
        self.include_services = include_services
        self.include_resources = include_resources


class GetSystemStatusResponse(_message.Message):
    """
    Response with system status
    
    Attributes:
        status: Overall system status
        services: Service statuses
        resources: Resource usage
        metrics: System metrics
        uptime: System uptime
        metadata: Response metadata
    """
    
    class ServiceStatus(_message.Message):
        """Service status information"""
        __slots__ = ['name', 'status', 'health', 'latency_ms', 'error_rate']
        
        def __init__(self,
                     name: str = "",
                     status: str = "",
                     health: str = "",
                     latency_ms: float = 0.0,
                     error_rate: float = 0.0):
            super(GetSystemStatusResponse.ServiceStatus, self).__init__()
            self.name = name
            self.status = status
            self.health = health
            self.latency_ms = latency_ms
            self.error_rate = error_rate
    
    class ResourceUsage(_message.Message):
        """Resource usage information"""
        __slots__ = ['cpu_percent', 'memory_percent', 'disk_percent',
                     'gpu_percent', 'network_io']
        
        def __init__(self,
                     cpu_percent: float = 0.0,
                     memory_percent: float = 0.0,
                     disk_percent: float = 0.0,
                     gpu_percent: float = 0.0,
                     network_io: Optional[Dict[str, float]] = None):
            super(GetSystemStatusResponse.ResourceUsage, self).__init__()
            self.cpu_percent = cpu_percent
            self.memory_percent = memory_percent
            self.disk_percent = disk_percent
            self.gpu_percent = gpu_percent
            if network_io:
                self.network_io.update(network_io)
    
    __slots__ = ['status', 'services', 'resources', 'metrics', 'uptime', 'metadata']
    
    def __init__(self,
                 status: str = "",
                 services: Optional[List[ServiceStatus]] = None,
                 resources: Optional[ResourceUsage] = None,
                 metrics: Optional[List[Metric]] = None,
                 uptime: Optional[duration_pb2.Duration] = None,
                 metadata: Optional[types_pb2.ResponseMetadata] = None):
        super(GetSystemStatusResponse, self).__init__()
        self.status = status
        if services:
            self.services.extend(services)
        if resources:
            self.resources.CopyFrom(resources)
        if metrics:
            self.metrics.extend(metrics)
        if uptime:
            self.uptime.CopyFrom(uptime)
        if metadata:
            self.metadata.CopyFrom(metadata)


class CreateAlertRequest(_message.Message):
    """
    Request to create alert rule
    
    Attributes:
        name: Alert name
        condition: Alert condition expression
        severity: Alert severity
        actions: Alert actions
        cooldown: Cooldown period
    """
    __slots__ = ['name', 'condition', 'severity', 'actions', 'cooldown']
    
    def __init__(self,
                 name: str = "",
                 condition: str = "",
                 severity: int = 0,
                 actions: Optional[List[str]] = None,
                 cooldown: Optional[duration_pb2.Duration] = None):
        super(CreateAlertRequest, self).__init__()
        self.name = name
        self.condition = condition
        self.severity = severity
        if actions:
            self.actions.extend(actions)
        if cooldown:
            self.cooldown.CopyFrom(cooldown)


class CreateAlertResponse(_message.Message):
    """
    Response for alert creation
    
    Attributes:
        alert_id: Created alert identifier
        status: Creation status
        metadata: Response metadata
    """
    __slots__ = ['alert_id', 'status', 'metadata']
    
    def __init__(self,
                 alert_id: str = "",
                 status: str = "",
                 metadata: Optional[types_pb2.ResponseMetadata] = None):
        super(CreateAlertResponse, self).__init__()
        self.alert_id = alert_id
        self.status = status
        if metadata:
            self.metadata.CopyFrom(metadata)


# Register message types
_sym_db.RegisterMessage(Metric)
_sym_db.RegisterMessage(MetricBatch)
_sym_db.RegisterMessage(Alert)
_sym_db.RegisterMessage(RecordMetricsRequest)
_sym_db.RegisterMessage(RecordMetricsResponse)
_sym_db.RegisterMessage(QueryMetricsRequest)
_sym_db.RegisterMessage(QueryMetricsResponse)
_sym_db.RegisterMessage(GetSystemStatusRequest)
_sym_db.RegisterMessage(GetSystemStatusResponse)
_sym_db.RegisterMessage(CreateAlertRequest)
_sym_db.RegisterMessage(CreateAlertResponse)
